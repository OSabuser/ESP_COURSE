use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::env;
use std::fs;
use std::path::Path;

#[derive(Debug, Serialize, Deserialize)]
struct AppConfig {
    device_name: String,
    log_level: String,
    button_long_press_threshold: u32,
    button_long_hold_threshold: u32,
}

fn main() -> Result<()> {
    linker_be_nice();
    // make sure linkall.x is the last linker script (otherwise might cause problems with flip-link)
    println!("cargo:rustc-link-arg=-Tlinkall.x");

    // –ü–æ–ª—É—á–∞–µ–º –ø—É—Ç—å –∫ OUT_DIR (–∫—É–¥–∞ cargo –ø–æ–ª–æ–∂–∏—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ñ–∞–π–ª)
    let out_dir = env::var("OUT_DIR").context("OUT_DIR not set")?;
    let out_path = Path::new(&out_dir);

    // –ß–∏—Ç–∞–µ–º –∫–æ–Ω—Ñ–∏–≥ –∏–∑ JSON —Ñ–∞–π–ª–∞
    let config_path = Path::new("config.json");

    if !config_path.exists() {
        println!("cargo:warning=config.json not found, using defaults");
        write_default_configs(out_path)?;
        return Ok(());
    }

    let config_str = fs::read_to_string(config_path).context("Failed to read configs.json")?;

    let config: AppConfig =
        serde_json::from_str(&config_str).context("Failed to parse configs.json")?;

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º Rust —Ñ–∞–π–ª —Å –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞–º–∏
    generate_config_file(out_path, &config)?;

    println!("cargo:rerun-if-changed=configs.json");

    Ok(())
}

#[allow(clippy::unwrap_used)]
#[allow(clippy::indexing_slicing)]
fn linker_be_nice() {
    let args: Vec<String> = std::env::args().collect();
    if args.len() > 1 {
        let kind = &args[1];
        let what = &args[2];

        match kind.as_str() {
            "undefined-symbol" => match what.as_str() {
                "_defmt_timestamp" => {
                    eprintln!();
                    eprintln!(
                        "üí° `defmt` not found - make sure `defmt.x` is added as a linker script and you have included `use defmt_rtt as _;`"
                    );
                    eprintln!();
                }
                "_stack_start" => {
                    eprintln!();
                    eprintln!("üí° Is the linker script `linkall.x` missing?");
                    eprintln!();
                }
                "esp_rtos_initialized" | "esp_rtos_yield_task" | "esp_rtos_task_create" => {
                    eprintln!();
                    eprintln!(
                        "üí° `esp-radio` has no scheduler enabled. Make sure you have initialized `esp-rtos` or provided an external scheduler."
                    );
                    eprintln!();
                }
                "embedded_test_linker_file_not_added_to_rustflags" => {
                    eprintln!();
                    eprintln!(
                        "üí° `embedded-test` not found - make sure `embedded-test.x` is added as a linker script for tests"
                    );
                    eprintln!();
                }
                _ => (),
            },
            // we don't have anything helpful for "missing-lib" yet
            _ => {
                std::process::exit(1);
            }
        }

        std::process::exit(0);
    }

    println!(
        "cargo:rustc-link-arg=-Wl,--error-handling-script={}",
        std::env::current_exe().unwrap().display()
    );
}

fn generate_config_file(out_path: &Path, config: &AppConfig) -> Result<()> {
    let rust_code = format!(
        r#"// This file is auto-generated by build.rs - DO NOT EDIT

/// Configuration loaded from configs.json at compile time
pub struct AppConfig;

impl AppConfig {{
    /// Device name/identifier
    pub const DEVICE_NAME: &str = "{}";
    
    /// Log level
    pub const LOG_LEVEL: &str = "{}";

    /// Update interval in milliseconds
    pub const BTN_LONG_PRESS_THRESHOLD_MS: u32 = {};

    /// Update interval in milliseconds
    pub const BTN_LONG_HOLD_THRESHOLD_MS: u32 = {};
}}

#[cfg(test)]
mod tests {{
    use super::*;

    #[test]
    fn test_config_values() {{
        assert!(!AppConfig::DEVICE_NAME.is_empty());
        assert!(AppConfig::BTN_LONG_PRESS_THRESHOLD_MS > 0);
        assert!(AppConfig::BTN_LONG_HOLD_THRESHOLD_MS > 0);
    }}
}}
"#,
        config.device_name,
        config.log_level,
        config.button_long_press_threshold,
        config.button_long_hold_threshold,
    );

    let config_file_path = out_path.join("config.rs");
    fs::write(&config_file_path, rust_code).context("Failed to write config.rs")?;

    println!("cargo:warning=Generated config at: {config_file_path:?}");

    Ok(())
}

fn write_default_configs(out_path: &Path) -> Result<()> {
    let defaults = r#"// This file is auto-generated by build.rs (using defaults) - DO NOT EDIT

pub struct AppConfig;

impl AppConfig {
    pub const DEVICE_NAME: &str = "ESP32-TESTING";
    pub const LOG_LEVEL: &str = "INFO";
    pub const BTN_LONG_HOLD_THRESHOLD_MS: u32 = 2000;
    pub const BTN_LONG_PRESS_THRESHOLD_MS: u32 = 300;
}
"#;

    let config_file_path = out_path.join("config.rs");
    fs::write(&config_file_path, defaults).context("Failed to write default config.rs")?;

    Ok(())
}
